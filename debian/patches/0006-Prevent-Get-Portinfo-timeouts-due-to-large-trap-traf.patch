From d4588cccb30e756352d8354421a509e76e7d33a5 Mon Sep 17 00:00:00 2001
From: Scott Breyer <scott.j.breyer@intel.com>
Date: Fri, 14 Dec 2018 11:46:28 -0500
Subject: [PATCH] Prevent Get(Portinfo) timeouts due to large trap traffic
 volume

---
 Esm/ib/src/smi/sa/sa_Trap.c | 96 ++++++++++++++++++++++-----------------------
 1 file changed, 47 insertions(+), 49 deletions(-)

diff --git a/Esm/ib/src/smi/sa/sa_Trap.c b/Esm/ib/src/smi/sa/sa_Trap.c
index 6c9ff2c..815bfc5 100644
--- a/Esm/ib/src/smi/sa/sa_Trap.c
+++ b/Esm/ib/src/smi/sa/sa_Trap.c
@@ -407,6 +407,13 @@ int sa_TrapNeedsLogging(Port_t *portp, uint8_t *trap_count)
 	return 0;
 }
 
+static
+void _copy_CapMaskTrap(Port_t **portp, STL_TRAP_CHANGE_CAPABILITY_DATA *ccTrapRef) {
+	(*portp)->portData->portInfo.CapabilityMask.AsReg32 = ccTrapRef->CapabilityMask.AsReg32;
+	(*portp)->portData->portInfo.CapabilityMask3.AsReg16 = ccTrapRef->CapabilityMask3.AsReg16;
+}
+
+
 /*
  * Used for forwarding traps that came from the outside.
  * In this case the caller pass the incoming mai packet
@@ -552,21 +559,21 @@ sa_Trap(Mai_t *maip) {
 		sm_discovery_needed("Port State Change Trap", notice.IssuerLID);
 	} else if (notice.Attributes.Generic.TrapNumber == MAD_SMT_CAPABILITYMASK_CHANGE) {
 		STL_TRAP_CHANGE_CAPABILITY_DATA ccTrap;
+		STL_TRAP_CHANGE_CAPABILITY_DATA ccTrapRef;
 		
 		BSWAPCOPY_STL_TRAP_CHANGE_CAPABILITY_DATA((STL_TRAP_CHANGE_CAPABILITY_DATA*)notice.Data, &ccTrap);
 		sm_get_lid_info(desc, notice.IssuerLID);
 
 		if (ccTrap.u.AsReg16 == 0) {
+			memcpy(&ccTrapRef, &ccTrap, sizeof(STL_TRAP_CHANGE_CAPABILITY_DATA));
 			/* Change fields are zero so one of the capability bits must
  			 * have changed. Compare the new CapabilityMask/Mask3 to the previous
 			 * CapabilityMask/Mask3 for this port to determine the appropriate
 			 * action to take*/
-			(void)vs_wrlock(&old_topology_lock);
+			vs_wrlock(&old_topology_lock);
 			portp = sm_find_node_and_port_lid(&old_topology, notice.IssuerLID, &nodep);
 			if (nodep && sm_valid_port(portp)){
 
-				STL_PORT_INFO portInfo;
-				Status_t status;
 
 				//determine which bits in Capability Mask/Mask3 changed
 				ccTrap.CapabilityMask.AsReg32 ^= portp->portData->portInfo.CapabilityMask.AsReg32;
@@ -574,65 +581,56 @@ sa_Trap(Mai_t *maip) {
 
 
 				if (ccTrap.CapabilityMask.s.IsSM){ //node's SM status changed, will need to trigger a sweep
-					if (!portp->portData->portInfo.CapabilityMask.s.IsSM){
+					if (ccTrapRef.CapabilityMask.s.IsSM){
 						IB_LOG_INFINI_INFO_FMT(__func__, 
 								"Received an (IS_SM on) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64,
-								ccTrap.CapabilityMask.AsReg32, desc, tid);
-						sm_discovery_needed("Port CapabilityMask Change isSM on", STL_LID_RESERVED);
+								ccTrapRef.CapabilityMask.AsReg32, desc, tid);
+						if (notice.IssuerLID != sm_lid){
+							sm_discovery_needed("Port CapabilityMask Change isSM on", STL_LID_RESERVED);
+						}
 					}else{
 						IB_LOG_INFINI_INFO_FMT(__func__, 
 								"Received an (IS_SM off) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64,
-								ccTrap.CapabilityMask.AsReg32, desc, tid);
+								ccTrapRef.CapabilityMask.AsReg32, desc, tid);
 						if (notice.IssuerLID != sm_lid){	
 							sm_discovery_needed("Port CapabilityMask Change isSM off", STL_LID_RESERVED);
 						}
 					}
 				}
 
-				// Get fresh port info
-				status = SM_Get_PortInfo_LR(fd_async_request, (1 << 24) | portp->index, sm_lid, portp->portData->lid, &portInfo);
-				if (status != VSTATUS_OK){
-					IB_LOG_WARN_FMT(__func__, 
-									"Cannot get PORTINFO for %s, TID="FMT_U64
-									" status=%d", desc, tid, status);
-				}else{
-					portp->portData->portInfo = portInfo;
-
-					/****************LOG BITS THAT CHANGED******************/
-					//portp->portData->portInfo contains current information
-					if(ccTrap.CapabilityMask.s.IsAutomaticMigrationSupported){
-							IB_LOG_INFINI_INFO_FMT(__func__, 
-									"Received an (IS_AUTOMATIC_MIGRATION_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64,
-									(portp->portData->portInfo.CapabilityMask.s.IsAutomaticMigrationSupported?"on":"off"),
-									ccTrap.CapabilityMask.AsReg32, desc, tid);
-					}
-					if(ccTrap.CapabilityMask.s.IsConnectionManagementSupported){
-							IB_LOG_INFINI_INFO_FMT(__func__, 
-									"Received an (IS_CONNECTION_MANAGEMENT_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
-									(portp->portData->portInfo.CapabilityMask.s.IsConnectionManagementSupported?"on":"off"), 
-									ccTrap.CapabilityMask.AsReg32, desc, tid);
-					}
-					if (ccTrap.CapabilityMask.s.IsDeviceManagementSupported){
-							IB_LOG_INFINI_INFO_FMT(__func__, 
-									"Received an (IS_DEVICE_MANAGEMENT_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
-									(portp->portData->portInfo.CapabilityMask.s.IsDeviceManagementSupported?"on":"off"),
-									ccTrap.CapabilityMask.AsReg32, desc, tid);
-					}
-					if(ccTrap.CapabilityMask.s.IsVendorClassSupported){
-							IB_LOG_INFINI_INFO_FMT(__func__, 
-									"Received an (IS_VENDOR_CLASS_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
-									(portp->portData->portInfo.CapabilityMask.s.IsVendorClassSupported?"on":"off"),
-									ccTrap.CapabilityMask.AsReg32, desc, tid);
-					}
-					if(ccTrap.CapabilityMask.s.IsCapabilityMaskNoticeSupported){
-							IB_LOG_INFINI_INFO_FMT(__func__, 
-									"Received an (IS_CAPABILITY_MASK_NOTICE_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
-									(portp->portData->portInfo.CapabilityMask.s.IsCapabilityMaskNoticeSupported?"on":"off"),
-									ccTrap.CapabilityMask.AsReg32, desc, tid);
-					}
+				if(ccTrap.CapabilityMask.s.IsAutomaticMigrationSupported){
+					IB_LOG_INFINI_INFO_FMT(__func__, 
+							"Received an (IS_AUTOMATIC_MIGRATION_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64,
+							(ccTrapRef.CapabilityMask.s.IsAutomaticMigrationSupported?"on":"off"),
+							ccTrapRef.CapabilityMask.AsReg32, desc, tid);
+				}
+				if(ccTrap.CapabilityMask.s.IsConnectionManagementSupported){
+					IB_LOG_INFINI_INFO_FMT(__func__, 
+							"Received an (IS_CONNECTION_MANAGEMENT_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
+							(ccTrapRef.CapabilityMask.s.IsConnectionManagementSupported?"on":"off"),
+							ccTrapRef.CapabilityMask.AsReg32, desc, tid);
+				}
+				if (ccTrap.CapabilityMask.s.IsDeviceManagementSupported){
+					IB_LOG_INFINI_INFO_FMT(__func__, 
+							"Received an (IS_DEVICE_MANAGEMENT_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
+							(ccTrapRef.CapabilityMask.s.IsDeviceManagementSupported?"on":"off"),
+							ccTrapRef.CapabilityMask.AsReg32, desc, tid);
 				}
+				if(ccTrap.CapabilityMask.s.IsVendorClassSupported){
+					IB_LOG_INFINI_INFO_FMT(__func__, 
+							"Received an (IS_VENDOR_CLASS_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
+							(ccTrapRef.CapabilityMask.s.IsVendorClassSupported?"on":"off"),
+							ccTrapRef.CapabilityMask.AsReg32, desc, tid);
+				}
+				if(ccTrap.CapabilityMask.s.IsCapabilityMaskNoticeSupported){
+					IB_LOG_INFINI_INFO_FMT(__func__, 
+							"Received an (IS_CAPABILITY_MASK_NOTICE_SUPPORTED %s) CAPABILITYMASK CHANGE [0x%.8X] trap from %s, TID="FMT_U64, 
+							(ccTrapRef.CapabilityMask.s.IsCapabilityMaskNoticeSupported?"on":"off"),
+							ccTrapRef.CapabilityMask.AsReg32, desc, tid);
+				}
+				_copy_CapMaskTrap(&portp, &ccTrapRef);
 			}
-			(void)vs_rwunlock(&old_topology_lock);
+			vs_rwunlock(&old_topology_lock);
 		} else {
 			/* A local change has occurred. */
 			IB_LOG_INFINI_INFO_FMT( "sa_Trap", 
-- 
2.1.4

